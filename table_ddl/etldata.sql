-- TABLES

create table etl_batch_dtls
(
	cidw_batch_id bigint default "identity"(108485, 0, '1,1'::text) not null,
	status char not null,
	startdttm timestamp not null,
	enddttm timestamp
)
sortkey(cidw_batch_id)
;

create table etl_process_dtls
(
	cidw_etlprocess_id integer default "identity"(108488, 0, '1,1'::text) not null,
	processname varchar(255) not null,
	processcategory varchar(50) not null,
	extractoverlap integer default 2 not null,
	source varchar(255) not null,
	lastcompletiondttm timestamp,
	filecount smallint default 8 not null,
	recsperfile integer,
	workflow varchar(50),
	etl_processor varchar(100),
	table_name varchar(50)
)
sortkey(cidw_etlprocess_id)
;

create table etl_process_exec_dtls
(
	cidw_etlload_id bigint default "identity"(108493, 0, '1,1'::text) not null,
	cidw_etlprocess_id integer not null,
	status char not null,
	startdttm timestamp not null,
	enddttm timestamp,
	rowsprocessed integer default 0,
	context varchar(255),
	cidw_batch_id bigint
)
sortkey(cidw_etlload_id)
;

create table ops_query_scan_stats
(
	username varchar(255) not null,
	qryid integer not null distkey,
	pid integer not null,
	schemaname varchar(255) not null,
	table_scanned varchar(255) not null,
	query_date date not null,
	cidw_etlload_id integer not null,
	cidw_load_dttm timestamp default getdate() not null
)
diststyle key
sortkey(query_date)
;

create table ops_system_table_stats
(
	statsdate date not null,
	schemaname varchar(255) not null,
	tablename varchar(255) not null distkey,
	tablerowcount bigint not null,
	tablesize_mb bigint not null,
	iscompressed char not null,
	cidw_etlload_id integer not null,
	cidw_load_dttm timestamp default getdate() not null
)
diststyle key
sortkey(statsdate, tablename)
;

create table etl_batch_load_map
(
	cidw_batch_id bigint,
	cidw_etlload_id bigint not null
)
sortkey(cidw_batch_id)
;

create table etl_param_lkp
(
	cidw_etlparam_id integer default "identity"(108594, 0, '1,1'::text) not null,
	processname varchar(255) not null,
	param_name varchar(255),
	context varchar(255),
	param_value varchar(65535)
)
sortkey(cidw_etlparam_id)
;

create table etl_process_snippet
(
	cidw_etlprocesssnippet_id integer default "identity"(108599, 0, '1,1'::text) not null,
	processname varchar(255) not null,
	snippetvalue varchar(65535),
	filenamepostfix varchar(255),
	envfilter varchar(1)
)
sortkey(cidw_etlprocesssnippet_id)
;

create table gf_loaderrorlog
(
	cidw_etlload_id bigint not null,
	cidw_etlprocess_id integer not null,
	cidw_extractfilename varchar(80) not null,
	source varchar(255) not null,
	entity varchar(255) not null,
	linenumber integer not null,
	columnname varchar(255) not null,
	rawline varchar(65535),
	rawfieldvalue varchar(65535),
	errorcode varchar(255),
	errorreason varchar(65535),
	cidw_load_dttm timestamp default getdate() not null
)
sortkey(cidw_extractfilename)
;

create table gf_loadtracker
(
	cidw_etlload_id bigint not null,
	cidw_etlprocess_id integer not null,
	cidw_extractfilename varchar(80) not null,
	source varchar(255) not null,
	entity varchar(255) not null,
	noofprocessedrecs integer,
	noofloadedrecs integer,
	nooferrorrecs integer,
	noofuniquekeys integer,
	isbadfile boolean,
	badfilereason varchar(65535),
	iserrfileexported boolean,
	cidw_load_dttm timestamp default getdate() not null
)
sortkey(cidw_extractfilename)
;

create table etl_control_file_dtls
(
	cidw_extractfilename varchar(256) not null,
	extract_tbl varchar(128) not null,
	extract_ts timestamp not null,
	drop_location varchar(512),
	source_database varchar(128) not null,
	filename varchar(128) not null,
	total_records integer not null,
	data_profile varchar(8192) not null,
	data_profile_hash varchar(80) not null,
	cidw_etlload_id integer not null,
	cidw_etlprocess_id integer not null,
	cidw_load_dttm timestamp default getdate() not null
)
;

create table table_data_quality_dtls
(
	table_schema varchar(100) not null,
	table_name varchar(100) not null,
	column_name varchar(100) not null,
	constraint_name varchar(100) not null,
	constraint_description varchar(1000),
	cnt_rowsaffected bigint not null,
	status char not null,
	cidw_etlload_id bigint not null,
	cidw_load_dttm timestamp default getdate() not null
)
;

create table etl_process_file_dtls
(
	cidw_etlload_id bigint not null encode zstd distkey,
	cidw_etlprocess_id integer not null,
	processname varchar(255) not null encode zstd,
	context varchar(255) not null encode zstd,
	source varchar(1024) encode zstd,
	destination varchar(1024) encode zstd,
	filename varchar(255) not null encode zstd,
	size_bytes bigint encode zstd,
	rows_processed integer default 0 not null encode zstd,
	transfer_status varchar(255) encode zstd,
	transfer_dtm timestamp encode zstd,
	duration_seconds integer encode zstd,
	cidw_batch_id bigint encode zstd,
	cidw_load_dttm timestamp default getdate() not null encode zstd
)
diststyle key
sortkey(cidw_etlload_id)
;

create table table_relationship_stats
(
	child_schema varchar(100) not null,
	child_table varchar(100) not null,
	parent_schema varchar(100) not null,
	parent_table varchar(100) not null,
	relationship varchar(1000) not null,
	cnt_parent bigint not null,
	cnt_child bigint not null,
	cnt_orphaned_child bigint not null,
	cnt_childless_parent bigint not null,
	max_children_per_parent bigint,
	avg_children_per_parent numeric(11,1),
	cidw_etlload_id bigint not null,
	cidw_load_dttm timestamp not null
)
sortkey(child_schema, child_table)
;

create table etl_process_exec_dtls_external
(
	cidw_etlload_id bigint default "identity"(2659323, 0, '1,1'::text) not null,
	cidw_etlprocess_id integer not null,
	status char not null,
	startdttm timestamp not null,
	enddttm timestamp,
	rowsprocessed integer default 0,
	context varchar(255),
	cidw_batch_id bigint
)
sortkey(cidw_etlload_id)
;

create table etl_process_file_dtls_external
(
	cidw_etlload_id bigint not null,
	cidw_etlprocess_id integer not null,
	processname varchar(255) not null,
	context varchar(255) not null,
	source varchar(1024),
	destination varchar(1024),
	filename varchar(255) not null,
	size_bytes bigint,
	rows_processed integer default 0 not null,
	transfer_status varchar(255),
	transfer_dtm timestamp,
	duration_seconds integer,
	cidw_batch_id bigint,
	cidw_load_dttm timestamp default getdate() not null
)
;

create table ops_query_exec_stats
(
	username varchar(255) not null,
	qryid integer not null distkey,
	pid integer not null,
	querytxt varchar(65535) not null,
	query_date date not null,
	starttime timestamp not null,
	endtime timestamp not null,
	query_starttime_hr integer not null,
	exec_time_secs integer not null,
	query_category varchar(255) not null,
	max_cpu_time integer default 0 not null,
	cpu_time integer default 0 not null,
	blocks_to_disk integer default 0 not null,
	blocks_read integer default 0 not null,
	cidw_etlload_id bigint not null,
	cidw_load_dttm timestamp default getdate() not null
)
diststyle key
sortkey(query_date)
;

create table ops_system_tables
(
	schemaname varchar(255) not null,
	tablename varchar(255) not null distkey,
	source varchar(50),
	tabletype varchar(50) not null,
	tablecategory varchar(255) not null,
	tableowner varchar(128) not null,
	tablelease date,
	onboardingdate date,
	cidw_etlload_id bigint not null,
	cidw_load_dttm timestamp default getdate() not null
)
diststyle key
sortkey(tablename)
;



-- VIEWS


CREATE VIEW v_etlrunreport AS SELECT primarydata.runendtag, primarydata.activity_category, primarydata.activity_name, primarydata.task_status, primarydata.start_time, primarydata.end_time, primarydata.activity_duration, primarydata.extracted_rows FROM (SELECT prd.processcategory AS activity_category, prd.processname AS activity_name, CASE WHEN (ped.status = 'S'::bpchar) THEN 'Succeeded'::character varying ELSE 'Incomplete'::character varying END AS task_status, ped.startdttm AS start_time, COALESCE(ped.enddttm, ped.startdttm) AS end_time, COALESCE(date_diff(('seconds'::character varying)::text, ped.startdttm, ped.enddttm), (0)::bigint) AS activity_duration, ped.rowsprocessed AS extracted_rows, min(CASE WHEN ((prd.processname)::text = (con.endofrunactivity)::text) THEN ped.enddttm ELSE con.fakerundate END) OVER(  ORDER BY ped.startdttm DESC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS runendtag FROM (((SELECT ped.cidw_etlload_id, ped.cidw_etlprocess_id, ped.status, ped.startdttm, ped.enddttm, ped.rowsprocessed FROM (etldata.etl_process_exec_dtls ped JOIN (SELECT 1 AS joiner, '2015-02-02 22:06:59'::timestamp without time zone AS startofrunreporting, '2099-01-01 00:00:01'::timestamp without time zone AS fakerundate, ('VacuumFull'::character varying)::character varying(255) AS endofrunactivity FROM etldata.etl_process_dtls WHERE ((etl_process_dtls.processname)::text = ('VacuumFull'::character varying)::text) LIMIT 1) con ON ((con.joiner = 1))) WHERE (ped.startdttm >= con.startofrunreporting) UNION ALL SELECT fakerunrow.cidw_etlload_id, fakerunrow.cidw_etlprocess_id, fakerunrow.status, fakerunrow.startdttm, fakerunrow.enddttm, fakerunrow.rowsprocessed FROM (SELECT 999999999999::bigint AS cidw_etlload_id, ped.cidw_etlprocess_id, 'I'::bpchar AS status, con.fakerundate AS startdttm, con.fakerundate AS enddttm, 0 AS rowsprocessed FROM (etldata.etl_process_dtls ped JOIN (SELECT 1 AS joiner, '2015-02-02 22:06:59'::timestamp without time zone AS startofrunreporting, '2099-01-01 00:00:01'::timestamp without time zone AS fakerundate, ('VacuumFull'::character varying)::character varying(255) AS endofrunactivity FROM etldata.etl_process_dtls WHERE ((etl_process_dtls.processname)::text = ('VacuumFull'::character varying)::text) LIMIT 1) con ON ((con.joiner = 1))) WHERE ((ped.processname)::text = (con.endofrunactivity)::text) LIMIT 1) fakerunrow) ped JOIN etldata.etl_process_dtls prd ON ((ped.cidw_etlprocess_id = prd.cidw_etlprocess_id))) JOIN (SELECT 1 AS joiner, '2015-02-02 22:06:59'::timestamp without time zone AS startofrunreporting, '2099-01-01 00:00:01'::timestamp without time zone AS fakerundate, ('VacuumFull'::character varying)::character varying(255) AS endofrunactivity FROM etldata.etl_process_dtls WHERE ((etl_process_dtls.processname)::text = ('VacuumFull'::character varying)::text) LIMIT 1) con ON ((con.joiner = 1))) WHERE (ped.startdttm >= con.startofrunreporting) ORDER BY ped.startdttm) primarydata ORDER BY primarydata.runendtag, primarydata.start_time
;

CREATE VIEW v_etlrunreport_today AS SELECT CASE WHEN (v_etlrunreport.runendtag <> '2099-01-01 00:00:01'::timestamp without time zone) THEN (((('Ended '::character varying)::text || ((convert_timezone(('US/Pacific'::character varying)::text, v_etlrunreport.runendtag))::character varying(30))::text) || (' (PST)'::character varying)::text))::character varying WHEN (v_etlrunreport.runendtag = '2099-01-01 00:00:01'::timestamp without time zone) THEN 'Partial Run'::character varying ELSE (v_etlrunreport.runendtag)::character varying(30) END AS run_tag, CASE WHEN ((v_etlrunreport.activity_category)::text = ('extract'::character varying)::text) THEN '1) Extract'::character varying WHEN ((v_etlrunreport.activity_category)::text = ('stage'::character varying)::text) THEN '2) Stage'::character varying WHEN ((v_etlrunreport.activity_category)::text = ('ods'::character varying)::text) THEN '3) ODS'::character varying WHEN ((v_etlrunreport.activity_category)::text = ('core'::character varying)::text) THEN '4) Core'::character varying WHEN ((v_etlrunreport.activity_category)::text = ('maintenance'::character varying)::text) THEN '5) Maint'::character varying ELSE '99) Other'::character varying END AS area, CASE WHEN ((v_etlrunreport.activity_name)::text ~~ ('%_fxas_%'::character varying)::text) THEN 'FXAS'::character varying WHEN ((v_etlrunreport.activity_name)::text ~~ ('%_fx_%'::character varying)::text) THEN 'FN'::character varying WHEN ((v_etlrunreport.activity_name)::text ~~ ('%_fv_%'::character varying)::text) THEN 'FV'::character varying ELSE '--'::character varying END AS source, v_etlrunreport.activity_name AS activity, v_etlrunreport.task_status AS status, convert_timezone(('US/Pacific'::character varying)::text, v_etlrunreport.start_time) AS start_pst, convert_timezone(('US/Pacific'::character varying)::text, v_etlrunreport.end_time) AS end_pst, (((v_etlrunreport.activity_duration)::numeric)::numeric(18,0) + (((((date_diff(('seconds'::character varying)::text, v_etlrunreport.start_time, v_etlrunreport.end_time) % (60)::bigint))::numeric)::numeric(18,0) / 60.00))::numeric(3,2)) AS minutes, v_etlrunreport.extracted_rows AS src_rows FROM etldata.v_etlrunreport WHERE ((v_etlrunreport.runendtag IN (SELECT DISTINCT v_etlrunreport.runendtag FROM etldata.v_etlrunreport ORDER BY v_etlrunreport.runendtag DESC LIMIT 2)) AND (NOT (((v_etlrunreport.runendtag = '2099-01-01 00:00:01'::timestamp without time zone) AND ((v_etlrunreport.activity_name)::text = ('vacuumfull'::character varying)::text)) AND (v_etlrunreport.start_time = v_etlrunreport.end_time)))) ORDER BY v_etlrunreport.end_time
;

CREATE VIEW v_etlrunreport_area AS SELECT tday.area, tday.source, min(tday.start_pst) AS start_pst, "max"(tday.end_pst) AS end_pst, sum(tday.minutes) AS total_run_time FROM etldata.v_etlrunreport_today tday WHERE ((tday.status)::text = ('Succeeded'::character varying)::text) GROUP BY tday.area, tday.source ORDER BY tday.area, tday.source
;

CREATE VIEW v_etlrunreport_stats AS SELECT CASE WHEN (etlrunreportstats.runendtag <> '2099-01-01 00:00:01'::timestamp without time zone) THEN (((('Ended '::character varying)::text || ((convert_timezone(('US/Pacific'::character varying)::text, etlrunreportstats.runendtag))::character varying(30))::text) || (' (PST)'::character varying)::text))::character varying WHEN (etlrunreportstats.runendtag = '2099-01-01 00:00:01'::timestamp without time zone) THEN 'Partial Run'::character varying ELSE (etlrunreportstats.runendtag)::character varying(30) END AS run_tag, etlrunreportstats.completed, etlrunreportstats.minutesduration AS run_minutes_duration, ((((((((etlrunreportstats.minutesduration / 60))::character varying(40))::text || ('h '::character varying)::text) || (((etlrunreportstats.minutesduration % (60)::bigint))::character varying(40))::text) || ('m '::character varying)::text) || (((etlrunreportstats.secondsduration % (60)::bigint))::character varying(40))::text) || ('s'::character varying)::text) AS run_duration, etlrunreportstats.activityduration AS activity_duration, etlrunreportstats.activitiessucceeded AS activity_instances_succeeded, etlrunreportstats.activitiesinstancesincomplete AS activity_instances_failed FROM (SELECT v_etlrunreport.runendtag, "max"((CASE WHEN ((v_etlrunreport.activity_name)::text = ('vacuumfull'::character varying)::text) THEN 'Yes'::character varying ELSE 'No'::character varying END)::text) AS completed, date_diff(('minutes'::character varying)::text, min(v_etlrunreport.start_time), "max"(v_etlrunreport.end_time)) AS minutesduration, date_diff(('seconds'::character varying)::text, min(v_etlrunreport.start_time), "max"(v_etlrunreport.end_time)) AS secondsduration, sum(v_etlrunreport.activity_duration) AS activityduration, sum(CASE WHEN ((v_etlrunreport.task_status)::text = ('Succeeded'::character varying)::text) THEN 1 ELSE 0 END) AS activitiessucceeded, sum(CASE WHEN ((v_etlrunreport.task_status)::text = ('Incomplete'::character varying)::text) THEN 1 ELSE 0 END) AS activitiesinstancesincomplete FROM etldata.v_etlrunreport WHERE (v_etlrunreport.runendtag IS NOT NULL) GROUP BY v_etlrunreport.runendtag ORDER BY v_etlrunreport.runendtag DESC LIMIT 10) etlrunreportstats WHERE (NOT ((etlrunreportstats.runendtag = '2099-01-01 00:00:01'::timestamp without time zone) AND (etlrunreportstats.activitiessucceeded = 0))) ORDER BY etlrunreportstats.runendtag DESC
;

CREATE VIEW v_gf_loadtracker AS SELECT gf_loadtracker.cidw_etlload_id AS "load id", gf_loadtracker.cidw_etlprocess_id AS "process id", gf_loadtracker.cidw_load_dttm AS "utc time processed", gf_loadtracker.source AS "data source", gf_loadtracker.entity, gf_loadtracker.cidw_extractfilename AS "filename in error", COALESCE(gf_loadtracker.noofprocessedrecs, 0) AS "records processed", COALESCE(gf_loadtracker.noofloadedrecs, 0) AS "records loaded", COALESCE(gf_loadtracker.nooferrorrecs, 0) AS "records in error", COALESCE(gf_loadtracker.noofuniquekeys, 0) AS "number of uniques", gf_loadtracker.isbadfile AS "bad file?", COALESCE(gf_loadtracker.badfilereason, 'N/A'::character varying) AS "bad file reason" FROM etldata.gf_loadtracker ORDER BY gf_loadtracker.cidw_load_dttm DESC
;

CREATE VIEW v_etlrunreport_extract_alerts AS SELECT y.activity_name, y.start_date, y.daily_row_count, y.total_row_count, y.avg_row_count, y.avg_row_count2, y.avg_row_count3, y.stddev, CASE WHEN (y.avg_row_count = 0) THEN 1 WHEN ((((y.daily_row_count)::double precision / (y.avg_row_count)::double precision) >= (0.90)::double precision) AND (((y.daily_row_count)::double precision / (y.avg_row_count)::double precision) <= (1.10)::double precision)) THEN 0 ELSE 1 END AS one_day_avg_alert, CASE WHEN (y.daily_row_count = 0) THEN NULL::double precision ELSE ((y.daily_row_count)::double precision / (y.avg_row_count)::double precision) END AS one_day_percent_of_avg, CASE WHEN (y.avg_row_count2 = 0) THEN 1 WHEN ((((y.daily_row_count)::double precision / (y.avg_row_count2)::double precision) >= (0.90)::double precision) AND (((y.daily_row_count)::double precision / (y.avg_row_count2)::double precision) <= (1.10)::double precision)) THEN 0 ELSE 1 END AS ten_day_avg_alert, CASE WHEN (y.avg_row_count2 = 0) THEN NULL::double precision ELSE ((y.daily_row_count)::double precision / (y.avg_row_count2)::double precision) END AS ten_day_percent_of_avg, CASE WHEN (y.avg_row_count3 = 0) THEN 1 WHEN ((((y.daily_row_count)::double precision / (y.avg_row_count3)::double precision) >= (0.90)::double precision) AND (((y.daily_row_count)::double precision / (y.avg_row_count3)::double precision) <= (1.10)::double precision)) THEN 0 ELSE 1 END AS thirty_day_avg_alert, CASE WHEN (y.avg_row_count3 = 0) THEN NULL::double precision ELSE ((y.daily_row_count)::double precision / (y.avg_row_count3)::double precision) END AS thirty_day_percent_of_avg FROM (SELECT x.activity_name, x.start_date, x.daily_row_count, sum(x.daily_row_count) OVER(  PARTITION BY x.activity_name ORDER BY x.activity_name, x.start_date ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS total_row_count, avg(x.daily_row_count) OVER(  PARTITION BY x.activity_name ORDER BY x.activity_name, x.start_date ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS avg_row_count, avg(x.daily_row_count) OVER(  PARTITION BY x.activity_name ORDER BY x.activity_name, x.start_date ROWS BETWEEN 10 PRECEDING AND CURRENT ROW) AS avg_row_count2, avg(x.daily_row_count) OVER(  PARTITION BY x.activity_name ORDER BY x.activity_name, x.start_date ROWS BETWEEN 30 PRECEDING AND CURRENT ROW) AS avg_row_count3, round(stddev_pop((x.daily_row_count)::double precision) OVER(  PARTITION BY x.activity_name ORDER BY x.activity_name, x.start_date ROWS BETWEEN 10 PRECEDING AND CURRENT ROW)) AS stddev FROM (SELECT w.activity_name, w.start_date, sum(w.extracted_rows) AS daily_row_count FROM (SELECT v_etlrunreport.activity_name, (v_etlrunreport.start_time)::date AS start_date, v_etlrunreport.extracted_rows FROM etldata.v_etlrunreport WHERE (v_etlrunreport.start_time > date_add('day'::text, (-100)::bigint, getdate()))) w GROUP BY w.activity_name, w.start_date) x) y ORDER BY y.activity_name, y.start_date DESC
;

CREATE VIEW v_generate_tbl_ddl AS SELECT derived_table4.schemaname, derived_table4.tablename, derived_table4.seq, derived_table4.ddl FROM (SELECT derived_table3.schemaname, derived_table3.tablename, derived_table3.seq, derived_table3.ddl FROM (((((((((((((((((((((SELECT n.nspname AS schemaname, c.relname AS tablename, 0 AS seq, '----------------------------------------------------------------------'::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char") UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 1 AS seq, ((((('--  Filename:                    '::text + (n.nspname)::text) + '_'::text) + (c.relname)::text) + '.sql'::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 2 AS seq, (((('--  Table or View:               '::text + (n.nspname)::text) + '.'::text) + (c.relname)::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 3 AS seq, '--'::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 4 AS seq, '--  Revision History'::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 5 AS seq, '--  Author          \011Date             Description'::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 5 AS seq, (('--  Sys Generated       '::text + (((getdate())::date)::character varying)::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 6 AS seq, '----------------------------------------------------------------------'::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 7 AS seq, ((((('--DROP TABLE IF EXISTS '::text + (n.nspname)::text) + '.'::text) + (c.relname)::text) + ';'::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 8 AS seq, (((('CREATE TABLE IF NOT EXISTS '::text + (n.nspname)::text) + '.'::text) + (c.relname)::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 9 AS seq, '('::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT derived_table1.schemaname, derived_table1.tablename, derived_table1.seq, ((((((((((('\011'::text + derived_table1.col_delim) + (derived_table1.col_name)::text) + '\011\011'::text) + rpad(derived_table1.col_datatype, 20, ' '::text)) + '\011'::text) + derived_table1.col_nullable) + '\011'::text) + rpad(derived_table1.col_encoding, 20, ' '::text)) + '\011'::text) + derived_table1.col_default))::character varying AS ddl FROM (SELECT n.nspname AS schemaname, c.relname AS tablename, (100000000 + a.attnum) AS seq, CASE WHEN (a.attnum > 1) THEN ','::text ELSE ''::text END AS col_delim, CASE WHEN (len((a.attname)::text) < 30) THEN (rpad((a.attname)::text, 30, ' '::text))::name ELSE a.attname END AS col_name, CASE WHEN (strpos(upper(format_type(a.atttypid, a.atttypmod)), 'CHARACTER VARYING'::text) > 0) THEN "replace"(upper(format_type(a.atttypid, a.atttypmod)), 'CHARACTER VARYING'::text, 'VARCHAR'::text) WHEN (strpos(upper(format_type(a.atttypid, a.atttypmod)), 'CHARACTER'::text) > 0) THEN "replace"(upper(format_type(a.atttypid, a.atttypmod)), 'CHARACTER'::text, 'CHAR'::text) WHEN (strpos(upper(format_type(a.atttypid, a.atttypmod)), 'TIMESTAMP WITHOUT TIME ZONE'::text) > 0) THEN 'TIMESTAMP'::text ELSE upper(format_type(a.atttypid, a.atttypmod)) END AS col_datatype, CASE WHEN (format_encoding((a.attencodingtype)::integer) = 'none'::bpchar) THEN ''::text ELSE ('ENCODE '::text + (format_encoding((a.attencodingtype)::integer))::text) END AS col_encoding, CASE WHEN (a.atthasdef IS TRUE) THEN ('DEFAULT '::text + adef.adsrc) ELSE ''::text END AS col_default, CASE WHEN (a.attnotnull IS TRUE) THEN 'NOT NULL'::text ELSE 'NULL    '::text END AS col_nullable FROM (((pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) JOIN pg_attribute a ON ((c.oid = a.attrelid))) LEFT JOIN pg_attrdef adef ON (((a.attrelid = adef.adrelid) AND (a.attnum = adef.adnum)))) WHERE ((c.relkind = 'r'::"char") AND (a.attnum > 0)) ORDER BY a.attnum) derived_table1) UNION (SELECT n.nspname AS schemaname, c.relname AS tablename, (200000000 + (con.oid)::integer) AS seq, (('\011,'::text + pg_get_constraintdef(con.oid)))::character varying AS ddl FROM ((pg_constraint con JOIN pg_class c ON (((c.relnamespace = con.connamespace) AND (c.oid = con.conrelid)))) JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE ((c.relkind = 'r'::"char") AND (pg_get_constraintdef(con.oid) !~~ 'FOREIGN KEY%'::text)) ORDER BY (200000000 + (con.oid)::integer))) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 299999999 AS seq, ')'::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 300000000 AS seq, 'BACKUP NO'::character varying AS ddl FROM ((pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) JOIN (SELECT split_part((pg_conf."key")::text, '_'::text, 5) AS id FROM pg_conf WHERE ((pg_conf."key" ~~ 'pg_class_backup_%'::text) AND (split_part((pg_conf."key")::text, '_'::text, 4) = ((SELECT pg_database.oid FROM pg_database WHERE (pg_database.datname = current_database())))::text))) t ON ((t.id = (c.oid)::text))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 1 AS seq, '--WARNING: This DDL inherited the BACKUP NO property from the source table'::character varying AS ddl FROM ((pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) JOIN (SELECT split_part((pg_conf."key")::text, '_'::text, 5) AS id FROM pg_conf WHERE ((pg_conf."key" ~~ 'pg_class_backup_%'::text) AND (split_part((pg_conf."key")::text, '_'::text, 4) = ((SELECT pg_database.oid FROM pg_database WHERE (pg_database.datname = current_database())))::text))) t ON ((t.id = (c.oid)::text))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 300000001 AS seq, (CASE WHEN (c.reldiststyle = 0) THEN 'DISTSTYLE EVEN'::text WHEN (c.reldiststyle = 1) THEN 'DISTSTYLE KEY'::text WHEN (c.reldiststyle = 8) THEN 'DISTSTYLE ALL'::text ELSE '<<Error - UNKNOWN DISTSTYLE>>'::text END)::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, (400000000 + a.attnum) AS seq, ((('DISTKEY ('::text + (a.attname)::text) + ')'::text))::character varying AS ddl FROM ((pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) JOIN pg_attribute a ON ((c.oid = a.attrelid))) WHERE (((c.relkind = 'r'::"char") AND (a.attisdistkey IS TRUE)) AND (a.attnum > 0))) UNION SELECT derived_table2.schemaname, derived_table2.tablename, derived_table2.seq, (CASE WHEN (derived_table2.min_sort < 0) THEN 'INTERLEAVED SORTKEY ('::text ELSE 'SORTKEY ('::text END)::character varying AS ddl FROM (SELECT n.nspname AS schemaname, c.relname AS tablename, 499999999 AS seq, min(a.attsortkeyord) AS min_sort FROM ((pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) JOIN pg_attribute a ON ((c.oid = a.attrelid))) WHERE (((c.relkind = 'r'::"char") AND (abs(a.attsortkeyord) > 0)) AND (a.attnum > 0)) GROUP BY n.nspname, c.relname, 3) derived_table2) UNION (SELECT n.nspname AS schemaname, c.relname AS tablename, (500000000 + abs(a.attsortkeyord)) AS seq, (CASE WHEN (abs(a.attsortkeyord) = 1) THEN (('\011'::text + (a.attname)::text) + ''::text) ELSE (('\011, '::text + (a.attname)::text) + ''::text) END)::character varying AS ddl FROM ((pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) JOIN pg_attribute a ON ((c.oid = a.attrelid))) WHERE (((c.relkind = 'r'::"char") AND (abs(a.attsortkeyord) > 0)) AND (a.attnum > 0)) ORDER BY abs(a.attsortkeyord))) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 599999999 AS seq, ')'::character varying AS ddl FROM ((pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) JOIN pg_attribute a ON ((c.oid = a.attrelid))) WHERE (((c.relkind = 'r'::"char") AND (abs(a.attsortkeyord) > 0)) AND (a.attnum > 0))) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 600000000 AS seq, ';'::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) derived_table3 UNION (SELECT 'zzzzzzzz'::name AS schemaname, 'zzzzzzzz'::name AS tablename, (700000000 + (con.oid)::integer) AS seq, ((((((('ALTER TABLE '::text + (n.nspname)::text) + '.'::text) + (c.relname)::text) + ' ADD '::text) + ((pg_get_constraintdef(con.oid))::character varying(1024))::text) + ';'::text))::character varying AS ddl FROM ((pg_constraint con JOIN pg_class c ON (((c.relnamespace = con.connamespace) AND (c.oid = con.conrelid)))) JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE ((c.relkind = 'r'::"char") AND (pg_get_constraintdef(con.oid) ~~ 'FOREIGN KEY%'::text)) ORDER BY (700000000 + (con.oid)::integer)) ORDER BY 1, 2, 3) derived_table4
;

CREATE VIEW v_generate_tbl_dtls AS SELECT n.nspname AS schemaname, c.relname AS tablename, (100000000 + a.attnum) AS seq, CASE WHEN (a.attnum > 1) THEN ','::text ELSE ''::text END AS col_delim, CASE WHEN (len((a.attname)::text) < 30) THEN (rpad((a.attname)::text, 30, ' '::text))::name ELSE a.attname END AS col_name, CASE WHEN (strpos(upper(format_type(a.atttypid, a.atttypmod)), 'CHARACTER VARYING'::text) > 0) THEN "replace"(upper(format_type(a.atttypid, a.atttypmod)), 'CHARACTER VARYING'::text, 'VARCHAR'::text) WHEN (strpos(upper(format_type(a.atttypid, a.atttypmod)), 'CHARACTER'::text) > 0) THEN "replace"(upper(format_type(a.atttypid, a.atttypmod)), 'CHARACTER'::text, 'CHAR'::text) WHEN (strpos(upper(format_type(a.atttypid, a.atttypmod)), 'TIMESTAMP WITHOUT TIME ZONE'::text) > 0) THEN 'TIMESTAMP'::text ELSE upper(format_type(a.atttypid, a.atttypmod)) END AS col_datatype, CASE WHEN (format_encoding((a.attencodingtype)::integer) = 'none'::bpchar) THEN ''::text ELSE ('ENCODE '::text + (format_encoding((a.attencodingtype)::integer))::text) END AS col_encoding, CASE WHEN (a.atthasdef IS TRUE) THEN ('DEFAULT '::text + adef.adsrc) ELSE ''::text END AS col_default, CASE WHEN (a.attnotnull IS TRUE) THEN 'NOT NULL'::text ELSE 'NULL    '::text END AS col_nullable FROM (((pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) JOIN pg_attribute a ON ((c.oid = a.attrelid))) LEFT JOIN pg_attrdef adef ON (((a.attrelid = adef.adrelid) AND (a.attnum = adef.adnum)))) WHERE ((c.relkind = 'r'::"char") AND (a.attnum > 0)) ORDER BY a.attnum
;

CREATE VIEW v_generate_encoding_ddl AS SELECT derived_table4.schemaname, derived_table4.tablename, derived_table4.seq, derived_table4.ddl FROM (((((((SELECT derived_table3.schemaname, derived_table3.tablename, derived_table3.seq, derived_table3.ddl FROM (((((((((((((((((((((SELECT n.nspname AS schemaname, c.relname AS tablename, 0 AS seq, '----------------------------------------------------------------------'::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char") UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 1 AS seq, ((((('--  Filename:                    '::text + (n.nspname)::text) + '_'::text) + (c.relname)::text) + '.sql'::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 2 AS seq, (((('--  Table or View:               '::text + (n.nspname)::text) + '.'::text) + (c.relname)::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 3 AS seq, '--'::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 4 AS seq, '--  Revision History'::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 5 AS seq, '--  Author          \011Date             Description'::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 5 AS seq, (('--  Sys Generated       '::text + (((getdate())::date)::character varying)::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 6 AS seq, '----------------------------------------------------------------------'::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 7 AS seq, ((((('--DROP TABLE IF EXISTS '::text + (n.nspname)::text) + '.'::text) + (c.relname)::text) + '_temp;'::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 8 AS seq, ((((('CREATE TABLE IF NOT EXISTS '::text + (n.nspname)::text) + '.'::text) + (c.relname)::text) + '_temp'::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 9 AS seq, '('::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT derived_table1.schemaname, derived_table1.tablename, derived_table1.seq, ((((((((((('\011'::text + derived_table1.col_delim) + (derived_table1.col_name)::text) + '\011\011'::text) + rpad(derived_table1.col_datatype, 20, ' '::text)) + '\011'::text) + derived_table1.col_nullable) + '\011'::text) + rpad(derived_table1.col_encoding, 20, ' '::text)) + '\011'::text) + derived_table1.col_default))::character varying AS ddl FROM (SELECT n.nspname AS schemaname, c.relname AS tablename, (100000000 + a.attnum) AS seq, CASE WHEN (a.attnum > 1) THEN ','::text ELSE ''::text END AS col_delim, CASE WHEN (len((a.attname)::text) < 30) THEN (rpad((a.attname)::text, 30, ' '::text))::name ELSE a.attname END AS col_name, CASE WHEN (strpos(upper(format_type(a.atttypid, a.atttypmod)), 'CHARACTER VARYING'::text) > 0) THEN "replace"(upper(format_type(a.atttypid, a.atttypmod)), 'CHARACTER VARYING'::text, 'VARCHAR'::text) WHEN (strpos(upper(format_type(a.atttypid, a.atttypmod)), 'CHARACTER'::text) > 0) THEN "replace"(upper(format_type(a.atttypid, a.atttypmod)), 'CHARACTER'::text, 'CHAR'::text) WHEN (strpos(upper(format_type(a.atttypid, a.atttypmod)), 'TIMESTAMP WITHOUT TIME ZONE'::text) > 0) THEN 'TIMESTAMP'::text ELSE upper(format_type(a.atttypid, a.atttypmod)) END AS col_datatype, CASE WHEN (format_encoding((a.attencodingtype)::integer) = 'none'::bpchar) THEN ''::text ELSE ('ENCODE '::text + (format_encoding((a.attencodingtype)::integer))::text) END AS col_encoding, CASE WHEN (a.atthasdef IS TRUE) THEN ('DEFAULT '::text + adef.adsrc) ELSE ''::text END AS col_default, CASE WHEN (a.attnotnull IS TRUE) THEN 'NOT NULL'::text ELSE 'NULL    '::text END AS col_nullable FROM (((pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) JOIN pg_attribute a ON ((c.oid = a.attrelid))) LEFT JOIN pg_attrdef adef ON (((a.attrelid = adef.adrelid) AND (a.attnum = adef.adnum)))) WHERE ((c.relkind = 'r'::"char") AND (a.attnum > 0)) ORDER BY a.attnum) derived_table1) UNION (SELECT n.nspname AS schemaname, c.relname AS tablename, (200000000 + (con.oid)::integer) AS seq, (('\011,'::text + pg_get_constraintdef(con.oid)))::character varying AS ddl FROM ((pg_constraint con JOIN pg_class c ON (((c.relnamespace = con.connamespace) AND (c.oid = con.conrelid)))) JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE ((c.relkind = 'r'::"char") AND (pg_get_constraintdef(con.oid) !~~ 'FOREIGN KEY%'::text)) ORDER BY (200000000 + (con.oid)::integer))) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 299999999 AS seq, ')'::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 300000000 AS seq, 'BACKUP NO'::character varying AS ddl FROM ((pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) JOIN (SELECT split_part((pg_conf."key")::text, '_'::text, 5) AS id FROM pg_conf WHERE ((pg_conf."key" ~~ 'pg_class_backup_%'::text) AND (split_part((pg_conf."key")::text, '_'::text, 4) = ((SELECT pg_database.oid FROM pg_database WHERE (pg_database.datname = current_database())))::text))) t ON ((t.id = (c.oid)::text))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 1 AS seq, '--WARNING: This DDL inherited the BACKUP NO property from the source table'::character varying AS ddl FROM ((pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) JOIN (SELECT split_part((pg_conf."key")::text, '_'::text, 5) AS id FROM pg_conf WHERE ((pg_conf."key" ~~ 'pg_class_backup_%'::text) AND (split_part((pg_conf."key")::text, '_'::text, 4) = ((SELECT pg_database.oid FROM pg_database WHERE (pg_database.datname = current_database())))::text))) t ON ((t.id = (c.oid)::text))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 300000001 AS seq, (CASE WHEN (c.reldiststyle = 0) THEN 'DISTSTYLE EVEN'::text WHEN (c.reldiststyle = 1) THEN 'DISTSTYLE KEY'::text WHEN (c.reldiststyle = 8) THEN 'DISTSTYLE ALL'::text ELSE '<<Error - UNKNOWN DISTSTYLE>>'::text END)::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, (400000000 + a.attnum) AS seq, ((('DISTKEY ('::text + (a.attname)::text) + ')'::text))::character varying AS ddl FROM ((pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) JOIN pg_attribute a ON ((c.oid = a.attrelid))) WHERE (((c.relkind = 'r'::"char") AND (a.attisdistkey IS TRUE)) AND (a.attnum > 0))) UNION SELECT derived_table2.schemaname, derived_table2.tablename, derived_table2.seq, (CASE WHEN (derived_table2.min_sort < 0) THEN 'INTERLEAVED SORTKEY ('::text ELSE 'SORTKEY ('::text END)::character varying AS ddl FROM (SELECT n.nspname AS schemaname, c.relname AS tablename, 499999999 AS seq, min(a.attsortkeyord) AS min_sort FROM ((pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) JOIN pg_attribute a ON ((c.oid = a.attrelid))) WHERE (((c.relkind = 'r'::"char") AND (abs(a.attsortkeyord) > 0)) AND (a.attnum > 0)) GROUP BY n.nspname, c.relname, 3) derived_table2) UNION (SELECT n.nspname AS schemaname, c.relname AS tablename, (500000000 + abs(a.attsortkeyord)) AS seq, (CASE WHEN (abs(a.attsortkeyord) = 1) THEN (('\011'::text + (a.attname)::text) + ''::text) ELSE (('\011, '::text + (a.attname)::text) + ''::text) END)::character varying AS ddl FROM ((pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) JOIN pg_attribute a ON ((c.oid = a.attrelid))) WHERE (((c.relkind = 'r'::"char") AND (abs(a.attsortkeyord) > 0)) AND (a.attnum > 0)) ORDER BY abs(a.attsortkeyord))) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 599999999 AS seq, ')'::character varying AS ddl FROM ((pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) JOIN pg_attribute a ON ((c.oid = a.attrelid))) WHERE (((c.relkind = 'r'::"char") AND (abs(a.attsortkeyord) > 0)) AND (a.attnum > 0))) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 600000000 AS seq, ';'::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) derived_table3 UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 699999999 AS seq, ((((('\012INSERT INTO '::text + (n.nspname)::text) + '.'::text) + (c.relname)::text) + '_temp'::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 799999999 AS seq, ((((('SELECT * FROM  '::text + (n.nspname)::text) + '.'::text) + (c.relname)::text) + ';'::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 899999999 AS seq, ((((('\012SELECT COUNT(*) FROM  '::text + (n.nspname)::text) + '.'::text) + (c.relname)::text) + '_temp;'::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 999999999 AS seq, ((((('SELECT COUNT(*) FROM  '::text + (n.nspname)::text) + '.'::text) + (c.relname)::text) + ';'::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 1999999999 AS seq, ((((('\012DROP TABLE IF EXISTS  '::text + (n.nspname)::text) + '.'::text) + (c.relname)::text) + ';'::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 1999999999 AS seq, ((((((('ALTER TABLE  '::text + (n.nspname)::text) + '.'::text) + (c.relname)::text) + '_temp RENAME TO '::text) + (c.relname)::text) + ';'::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char")) UNION SELECT n.nspname AS schemaname, c.relname AS tablename, 2999999999::bigint AS seq, ((((('\012SELECT COUNT(*) FROM '::text + (n.nspname)::text) + '.'::text) + (c.relname)::text) + ';'::text))::character varying AS ddl FROM (pg_namespace n JOIN pg_class c ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'r'::"char") ORDER BY 1, 2, 3) derived_table4
;

CREATE VIEW v_fandango_file_weekly_scorecard AS SELECT "replace"((etl_process_file_dtls.processname)::text, ('etl_extract_fandango_'::character varying)::text, (''::character varying)::text) AS table_name, split_part((etl_process_file_dtls.source)::text, ('/'::character varying)::text, 4) AS file_date, split_part((etl_process_file_dtls.source)::text, ('/'::character varying)::text, 5) AS file_hour, split_part((etl_process_file_dtls.destination)::text, ('/'::character varying)::text, 2) AS file_name, CASE WHEN (((split_part((etl_process_file_dtls.source)::text, ('/'::character varying)::text, 5))::integer % 2) <> 0) THEN 1 ELSE 0 END AS outside_processing_window, CASE WHEN ((etl_process_file_dtls.transfer_status)::text <> ('S'::character varying)::text) THEN 1 ELSE 0 END AS incomplete_processing_files, CASE WHEN (etl_process_file_dtls.rows_processed = 0) THEN 1 ELSE 0 END AS empty_file, a.total_records AS total_source_records, CASE WHEN ((etl_process_file_dtls.transfer_status)::text = ('S'::character varying)::text) THEN etl_process_file_dtls.rows_processed ELSE 0 END AS total_processed_records, etl_process_file_dtls.duration_seconds, etl_process_file_dtls.transfer_dtm AS process_start_time, etl_process_file_dtls.cidw_load_dttm, '' AS current_failure FROM (etldata.etl_process_file_dtls LEFT JOIN (SELECT DISTINCT "replace"((etl_control_file_dtls.cidw_extractfilename)::text, ('control.txt'::character varying)::text, ('part_01.txt.gz'::character varying)::text) AS filename, etl_control_file_dtls.total_records FROM etldata.etl_control_file_dtls) a USING (filename)) WHERE (((etl_process_file_dtls.cidw_load_dttm >= (getdate() - (30)::bigint)) AND ((etl_process_file_dtls.source)::text ~~ ('fandango-wb-exports/prod/Fandango/20%'::character varying)::text)) AND ((etl_process_file_dtls.processname)::text !~~ ('%LTD%'::character varying)::text))
;

CREATE VIEW v_generate_metadata AS ((((((((((((((((SELECT table_dtls.tablename, 0 AS seq, '----------------------------------------------------------------------' AS line_text FROM (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) table_dtls UNION SELECT table_dtls.tablename, 1 AS seq, ((('--  Filename:                       dev_'::text + (table_dtls.tablename)::text) + '_metadata_load.sql'::text))::character varying AS line_text FROM (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) table_dtls) UNION SELECT table_dtls.tablename, 2 AS seq, '--  Target Table Name:          etldata.etl_process_dtls, etldata.etl_param_lkp' AS line_text FROM (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) table_dtls) UNION SELECT table_dtls.tablename, 3 AS seq, '--  Revision History' AS line_text FROM (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) table_dtls) UNION SELECT table_dtls.tablename, 4 AS seq, '--  Author          Date        Description' AS line_text FROM (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) table_dtls) UNION SELECT table_dtls.tablename, 5 AS seq, (('--  Sys Generated   '::text + (((getdate())::date)::character varying)::text))::character varying AS line_text FROM (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) table_dtls) UNION SELECT table_dtls.tablename, 6 AS seq, '----------------------------------------------------------------------' AS line_text FROM (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) table_dtls) UNION SELECT td.tablename, 7 AS seq, ((((('BEGIN;\012\011DROP TABLE IF EXISTS #etl_process_dtls_'::text + (td.tablename)::text) + ';\012\011CREATE TABLE IF NOT EXISTS #etl_process_dtls_'::text) + (td.tablename)::text) + ' (LIKE etldata.etl_process_dtls);'::text))::character varying AS line_text FROM (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td WHERE (td.tablename IS NOT NULL)) UNION SELECT td.tablename, 8 AS seq, ((('\012\011INSERT INTO #etl_process_dtls_'::text + (td.tablename)::text) + '(\012\011\011cidw_etlprocess_id\012\011\011,processname\012\011\011,processcategory\012\011\011,extractoverlap\012\011\011,source\012\011\011,filecount\012\011\011,recsperfile\012\011\011,workflow\012\011\011,etl_processor\012\011\011,table_name\012\011)VALUES'::text))::character varying AS line_text FROM ((SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td JOIN (SELECT td.tablename, ped.processname, ped.cidw_etlprocess_id, ped.processcategory, ped.extractoverlap, ped.source, ped.filecount, ped.recsperfile, ped.workflow, ped.etl_processor, ped.table_name, (1000 + pg_catalog.row_number() OVER(  PARTITION BY ped.table_name ORDER BY ped.processcategory, ped.processname)) AS seq FROM (etldata.etl_process_dtls ped JOIN (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td ON (((ped.processname)::text = (td.processname)::text))) WHERE (ped.table_name IS NOT NULL)) ped ON (((td.processname)::text = (ped.processname)::text)))) UNION SELECT ped.tablename, ped.seq, (CASE WHEN (ped.seq > 1001) THEN ((((((((((((((((((((((('\011--'::text + (ped.processcategory)::text) + '\012\011,(\''::text) + (COALESCE(ped.cidw_etlprocess_id, 1))::text) + '\',\''::text) + (ped.processname)::text) + '\', \''::text) + (ped.processcategory)::text) + '\', '::text) + (ped.extractoverlap)::text) + ', \''::text) + (ped.source)::text) + '\', '::text) + (ped.filecount)::text) + ', '::text) + (ped.filecount)::text) + ', \''::text) + (ped.workflow)::text) + '\', \''::text) + (ped.etl_processor)::text) + '\', \''::text) + (COALESCE(ped.table_name, ''::character varying))::text) + '\''::text) + ')'::text) ELSE ((((((((((((((((((((((('\011--'::text + (COALESCE(ped.processcategory, ''::character varying))::text) + '\012\011(\''::text) + (COALESCE(ped.cidw_etlprocess_id, 1))::text) + '\',\''::text) + (COALESCE(ped.processname, ''::character varying))::text) + '\', \''::text) + (COALESCE(ped.processcategory, ''::character varying))::text) + '\', '::text) + (COALESCE(ped.extractoverlap, -1))::text) + ', \''::text) + (COALESCE(ped.source, ''::character varying))::text) + '\', '::text) + (COALESCE((ped.filecount)::integer, -1))::text) + ', '::text) + (COALESCE((ped.filecount)::integer, -1))::text) + ', \''::text) + (COALESCE(ped.workflow, ''::character varying))::text) + '\', \''::text) + (COALESCE(ped.etl_processor, ''::character varying))::text) + '\', \''::text) + (COALESCE(ped.table_name, ''::character varying))::text) + '\''::text) + ')'::text) END)::character varying AS line_text FROM ((SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td JOIN (SELECT td.tablename, ped.processname, ped.cidw_etlprocess_id, ped.processcategory, ped.extractoverlap, ped.source, ped.filecount, ped.recsperfile, ped.workflow, ped.etl_processor, ped.table_name, (1000 + pg_catalog.row_number() OVER(  PARTITION BY ped.table_name ORDER BY ped.processcategory, ped.processname)) AS seq FROM (etldata.etl_process_dtls ped JOIN (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td ON (((ped.processname)::text = (td.processname)::text))) WHERE (ped.table_name IS NOT NULL)) ped ON (((td.processname)::text = (ped.processname)::text)))) UNION SELECT td.tablename, 2000 AS seq, ((('\011;\012\011INSERT INTO etldata.etl_process_dtls(\012\011\011processname\012\011\011,processcategory\012\011\011,extractoverlap\012\011\011,source\012\011\011,filecount\012\011\011,recsperfile\012\011\011,workflow\012\011\011,etl_processor\012\011\011,table_name\012\011)\012\011 SELECT \012\011\011tmp.processname\012\011\011,tmp.processcategory\012\011\011,tmp.extractoverlap\012\011\011,tmp.source\012\011\011,tmp.filecount\012\011\011,tmp.recsperfile\012\011\011,tmp.workflow\012\011\011,tmp.etl_processor\012\011\011,tmp.table_name\012\011\012\011 FROM\012\011\011#etl_process_dtls_'::text + (td.tablename)::text) + ' AS tmp \012\011LEFT OUTER JOIN etldata.etl_process_dtls AS ped \012\011\011ON tmp.processname = ped.processname \012\011WHERE ped.processname IS NULL;'::text))::character varying AS line_text FROM ((SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td JOIN (SELECT td.tablename, ped.processname, ped.cidw_etlprocess_id, ped.processcategory, ped.extractoverlap, ped.source, ped.filecount, ped.recsperfile, ped.workflow, ped.etl_processor, ped.table_name, (1000 + pg_catalog.row_number() OVER(  PARTITION BY ped.table_name ORDER BY ped.processcategory, ped.processname)) AS seq FROM (etldata.etl_process_dtls ped JOIN (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td ON (((ped.processname)::text = (td.processname)::text))) WHERE (ped.table_name IS NOT NULL)) ped ON ((((td.processname)::text = (ped.processname)::text) AND ((td.tablename)::text = (ped.tablename)::text))))) UNION SELECT td.tablename, 3000 AS seq, ((('\012\011--UPDATE Existing Rows\012\011UPDATE \011etldata.etl_process_dtls \012\011SET \012\011\011processcategory\011    = tmp.processcategory \012\011\011,extractoverlap\011\011= tmp.extractoverlap \012\011\011,source\011\011\011\011= tmp.source \012\011\011,filecount\011\011\011= tmp.filecount\011\011\012\011\011,recsperfile\011\011= tmp.recsperfile\012\011\011,workflow           = tmp.workflow\012\011\011,etl_processor      = tmp.etl_processor\012\011\011,table_name         = tmp.table_name\012\011\011\012\011FROM \012\011( \012\011\011SELECT * FROM #etl_process_dtls_'::text + (td.tablename)::text) + ' \012\011) tmp \012\011WHERE  etldata.etl_process_dtls.processname = tmp.processname \012\011;'::text))::character varying AS line_text FROM ((SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td JOIN (SELECT td.tablename, ped.processname, ped.cidw_etlprocess_id, ped.processcategory, ped.extractoverlap, ped.source, ped.filecount, ped.recsperfile, ped.workflow, ped.etl_processor, ped.table_name, (1000 + pg_catalog.row_number() OVER(  PARTITION BY ped.table_name ORDER BY ped.processcategory, ped.processname)) AS seq FROM (etldata.etl_process_dtls ped JOIN (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td ON (((ped.processname)::text = (td.processname)::text))) WHERE (ped.table_name IS NOT NULL)) ped ON ((((td.processname)::text = (ped.processname)::text) AND ((td.tablename)::text = (ped.tablename)::text))))) UNION SELECT td.tablename, 4000 AS seq, '\012\011-- Delete current entries from etldata.etl_param_lkp\012\011DELETE FROM etldata.etl_param_lkp WHERE processname IN \012\011(' AS line_text FROM ((SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td JOIN (SELECT td.tablename, ped.processname, ped.cidw_etlprocess_id, ped.processcategory, ped.extractoverlap, ped.source, ped.filecount, ped.recsperfile, ped.workflow, ped.etl_processor, ped.table_name, (1000 + pg_catalog.row_number() OVER(  PARTITION BY ped.table_name ORDER BY ped.processcategory, ped.processname)) AS seq FROM (etldata.etl_process_dtls ped JOIN (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td ON (((ped.processname)::text = (td.processname)::text))) WHERE (ped.table_name IS NOT NULL)) ped ON (((td.processname)::text = (ped.processname)::text)))) UNION SELECT ped.tablename, (3000 + ped.seq) AS seq, (CASE WHEN (ped.seq > 1001) THEN (('\011\011,\''::text + (ped.processname)::text) + '\''::text) ELSE (('\011\011\''::text + (ped.processname)::text) + '\''::text) END)::character varying AS line_text FROM ((SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td JOIN (SELECT td.tablename, ped.processname, ped.cidw_etlprocess_id, ped.processcategory, ped.extractoverlap, ped.source, ped.filecount, ped.recsperfile, ped.workflow, ped.etl_processor, ped.table_name, (1000 + pg_catalog.row_number() OVER(  PARTITION BY ped.table_name ORDER BY ped.processcategory, ped.processname)) AS seq FROM (etldata.etl_process_dtls ped JOIN (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td ON (((ped.processname)::text = (td.processname)::text))) WHERE (ped.table_name IS NOT NULL)) ped ON (((td.tablename)::text = (ped.tablename)::text)))) UNION SELECT table_dtls.tablename, 5000 AS seq, '\011);' AS line_text FROM (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) table_dtls) UNION SELECT td.tablename, 6000 AS seq, '\012\011-- Create entries for Extract, Move, Stage and ODS in etldata.etl_param_lkp \012\011INSERT INTO etldata.etl_param_lkp (\012\011  \011processname \012\011\011,param_name \012\011\011,context \012\011\011,param_value \012\011) VALUES ' AS line_text FROM ((SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td JOIN (SELECT td.tablename, td.processcategory, td.processname, lkp.param_name, lkp.context, lkp.param_value, (7000 + pg_catalog.row_number() OVER(  PARTITION BY td.tablename ORDER BY td.tablename, td.processname, lkp.context, lkp.param_name)) AS seq, pg_catalog.row_number() OVER(  PARTITION BY td.tablename, td.processcategory ORDER BY td.processcategory) AS cat_seq FROM (etldata.etl_param_lkp lkp JOIN (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td ON (((lkp.processname)::text = (td.processname)::text)))) lkp ON (((td.tablename)::text = (lkp.tablename)::text))) WHERE ((lkp.seq >= 7001) AND (lkp.seq <= 7999))) UNION SELECT lkp.tablename, lkp.seq, (CASE WHEN ((lkp.seq > 7001) AND (lkp.cat_seq = 1)) THEN (((((((((('\011--'::text + (lkp.processcategory)::text) + '\012\011,(\''::text) + (lkp.processname)::text) + '\', \''::text) + (lkp.param_name)::text) + '\', \''::text) + (lkp.context)::text) + '\', \''::text) + "replace"((lkp.param_value)::text, '\\'::text, '\\\\'::text)) + '\')'::text) WHEN (lkp.seq > 7001) THEN (((((((('\011,(\''::text + (lkp.processname)::text) + '\', \''::text) + (lkp.param_name)::text) + '\', \''::text) + (lkp.context)::text) + '\', \''::text) + (lkp.param_value)::text) + '\')'::text) ELSE (((((((((('\011--'::text + (lkp.processcategory)::text) + '\012\011(\''::text) + (lkp.processname)::text) + '\', \''::text) + (lkp.param_name)::text) + '\', \''::text) + (lkp.context)::text) + '\', \''::text) + "replace"((lkp.param_value)::text, '\\'::text, '\\\\'::text)) + '\')'::text) END)::character varying AS line_text FROM ((SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td JOIN (SELECT td.tablename, td.processcategory, td.processname, lkp.param_name, lkp.context, lkp.param_value, (7000 + pg_catalog.row_number() OVER(  PARTITION BY td.tablename ORDER BY td.tablename, td.processname, lkp.context, lkp.param_name)) AS seq, pg_catalog.row_number() OVER(  PARTITION BY td.tablename, td.processcategory ORDER BY td.processcategory) AS cat_seq FROM (etldata.etl_param_lkp lkp JOIN (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) td ON (((lkp.processname)::text = (td.processname)::text)))) lkp ON (((td.tablename)::text = (lkp.tablename)::text)))) UNION SELECT table_dtls.tablename, 8000 AS seq, '; \012END;' AS line_text FROM (SELECT x.processcategory, x.processname, (x.total_len - (x.prefix + (x.total_len - x.postfix))) AS tablelen, x.tablename FROM (SELECT etl_process_dtls.processcategory, etl_process_dtls.processname, etl_process_dtls.table_name AS tablename, ((len((etl_process_dtls.processcategory)::text) + strpos((etl_process_dtls.processname)::text, (etl_process_dtls.processcategory)::text)) + 1) AS prefix, (len((etl_process_dtls.processname)::text) - (strpos(reverse((etl_process_dtls.processname)::text), '_'::text) - 1)) AS postfix, len((etl_process_dtls.processname)::text) AS total_len FROM etldata.etl_process_dtls) x) table_dtls ORDER BY 1, 2
;

